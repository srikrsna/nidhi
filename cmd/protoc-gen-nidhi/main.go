package main

import (
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/srikrsna/nidhi/gen/nidhi"
	"golang.org/x/exp/maps"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/anypb"
	"google.golang.org/protobuf/types/known/durationpb"
	"google.golang.org/protobuf/types/known/emptypb"
	"google.golang.org/protobuf/types/known/fieldmaskpb"
	"google.golang.org/protobuf/types/known/structpb"
	"google.golang.org/protobuf/types/known/timestamppb"
	"google.golang.org/protobuf/types/known/wrapperspb"
	"google.golang.org/protobuf/types/pluginpb"
)

const (
	generatedFilenameExtension = ".nidhi.go"
	generatedPackageDir        = "nidhi"
	nidhiPkg                   = protogen.GoImportPath("github.com/srikrsna/nidhi")
	strconvPkh                 = protogen.GoImportPath("strconv")
	contextPkg                 = protogen.GoImportPath("context")
	sqlPkg                     = protogen.GoImportPath("database/sql")
	jsoniterPkg                = protogen.GoImportPath("github.com/json-iterator/go")
	protojsonPkg               = protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")
	base64Pkg                  = protogen.GoImportPath("encoding/base64")
	jsonPkg                    = protogen.GoImportPath("encoding/json")
)

var (
	wktSet = map[protoreflect.FullName]bool{
		(new(structpb.NullValue)).Descriptor().FullName():                  true,
		(&structpb.Struct{}).ProtoReflect().Descriptor().FullName():        true,
		(&structpb.ListValue{}).ProtoReflect().Descriptor().FullName():     true,
		(&structpb.Value{}).ProtoReflect().Descriptor().FullName():         true,
		(&fieldmaskpb.FieldMask{}).ProtoReflect().Descriptor().FullName():  true,
		(&timestamppb.Timestamp{}).ProtoReflect().Descriptor().FullName():  true,
		(&durationpb.Duration{}).ProtoReflect().Descriptor().FullName():    true,
		(&anypb.Any{}).ProtoReflect().Descriptor().FullName():              true,
		(&emptypb.Empty{}).ProtoReflect().Descriptor().FullName():          true,
		(&wrapperspb.BoolValue{}).ProtoReflect().Descriptor().FullName():   true,
		(&wrapperspb.StringValue{}).ProtoReflect().Descriptor().FullName(): true,
		(&wrapperspb.BytesValue{}).ProtoReflect().Descriptor().FullName():  true,
		(&wrapperspb.Int32Value{}).ProtoReflect().Descriptor().FullName():  true,
		(&wrapperspb.Int64Value{}).ProtoReflect().Descriptor().FullName():  true,
		(&wrapperspb.UInt32Value{}).ProtoReflect().Descriptor().FullName(): true,
		(&wrapperspb.UInt64Value{}).ProtoReflect().Descriptor().FullName(): true,
		(&wrapperspb.FloatValue{}).ProtoReflect().Descriptor().FullName():  true,
		(&wrapperspb.DoubleValue{}).ProtoReflect().Descriptor().FullName(): true,
	}
)

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, file := range plugin.Files {
			if file.Generate {
				gen(plugin, file)
			}
		}
		return nil
	})
}

func gen(plugin *protogen.Plugin, file *protogen.File) {
	type messageToGen struct {
		*protogen.Message
		*protogen.Field
	}
	var messagesToGen []messageToGen
	for _, message := range file.Messages {
		for _, field := range message.Fields {
			if proto.GetExtension(field.Desc.Options(), nidhi.E_DocumentId).(bool) {
				messagesToGen = append(messagesToGen, messageToGen{message, field})
			}
		}
	}
	if len(messagesToGen) == 0 {
		return
	}
	generatedPackagePrefix := path.Join(path.Dir(file.GeneratedFilenamePrefix), generatedPackageDir)
	for _, message := range messagesToGen {
		pkgName := strings.ToLower(message.Message.GoIdent.GoName)
		genFile := plugin.NewGeneratedFile(
			path.Join(
				generatedPackagePrefix,
				pkgName,
				pkgName,
			)+generatedFilenameExtension,
			protogen.GoImportPath(path.Join(
				string(file.GoImportPath),
				generatedPackageDir,
				pkgName,
			)),
		)
		genHeader(genFile, message.Message)
		genMessage(genFile, message.Message, message.Field, plugin)
	}
}

func genHeader(g *protogen.GeneratedFile, msg *protogen.Message) {
	g.P("// Code generated by ", filepath.Base(os.Args[0]), ". DO NOT EDIT.")
	g.P("//")
	g.P("// Source: ", msg.Location.SourceFile)
	g.P()
	g.P("package ", strings.ToLower(msg.GoIdent.GoName))
	g.P()
}

func genMessage(g *protogen.GeneratedFile, message *protogen.Message, idField *protogen.Field, plugin *protogen.Plugin) {
	genNewStore(g, message, idField)
	genUpdatesType(g, message, idField, plugin)
	genSchema(g, message)
	genConj(g)
	genSchemaTypes(g, message, plugin)
	genUpdateMarshaler(g, message, idField, plugin)
}

func genUpdatesType(g *protogen.GeneratedFile, message *protogen.Message, idField *protogen.Field, plugin *protogen.Plugin) {
	g.P("// Updates is a ", message.GoIdent.GoName, " type with every field as optional.")
	g.P("//")
	g.P("// It can be used for partial updates using ")
	g.P("// [*nidhi.Store.Update] and [*nidhi.Store.UpdateMany].")
	g.P("type Updates struct {")
	for _, field := range message.Fields {
		if field == idField {
			continue
		}
		g.P(append([]any{field.GoName, " "}, append(lkpFieldType(field, plugin), " `json:\"", field.Desc.JSONName(), ",omitempty\"`")...)...)
	}
	g.P("}")
	g.P("")
}

func genUpdateMarshaler(g *protogen.GeneratedFile, message *protogen.Message, idField *protogen.Field, plugin *protogen.Plugin) {
	g.P("func (u *Updates) WriteJSON(w *", jsoniterPkg.Ident("Stream"), ") {")
	g.P("if u == nil {")
	g.P("w.WriteEmptyObject()")
	g.P("return")
	g.P("}")
	g.P("first := true")
	g.P("w.WriteObjectStart()")
	for _, field := range message.Fields {
		if field == idField {
			continue
		}
		g.P("if u.", field.GoName, " != nil {")
		g.P("if !first {")
		g.P("w.WriteMore()")
		g.P("}")
		g.P(`w.WriteObjectField("`, field.Desc.JSONName(), `")`)
		genUpdateFieldMarshaler(g, field.Desc, "*u."+field.GoName, false)
		g.P("first = false")
		g.P("}")
	}
	g.P("w.WriteObjectEnd()")
	g.P("}")
}

func genUpdateFieldMarshaler(g *protogen.GeneratedFile, fd protoreflect.FieldDescriptor, name string, inList bool) {
	switch {
	case fd.IsList() && !inList:
		g.P("w.WriteArrayStart()")
		g.P("ap := false")
		g.P("for _, v := range ", name, " {")
		g.P("if !ap {")
		g.P("w.WriteMore()")
		g.P("}")
		genUpdateFieldMarshaler(g, fd, "v", true)
		g.P("ap = false")
		g.P("}")
		g.P("w.WriteArrayEnd()")
	case fd.IsMap():
		g.P("w.WriteObjectStart()")
		g.P("mp := false")
		g.P("for k, v := range ", name, " {")
		g.P("if !mp {")
		g.P("w.WriteMore()")
		g.P("}")
		switch fd.MapKey().Kind() {
		case protoreflect.BoolKind:
			g.P("w.WriteObjectField(strconv.FormatBool(k))")
		case protoreflect.StringKind:
			g.P("w.WriteObjectField(k)")
		case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
			g.P("w.WriteObjectField(strconv.FormatInt(int64(k), 10))")
		case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
			g.P("w.WriteObjectField(strconv.FormatInt(k, 10))")
		case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
			g.P("w.WriteObjectField(strconv.FormatUint(uint64(k), 10))")
		case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
			g.P("w.WriteObjectField(strconv.FormatUint(k, 10))")
		}
		genUpdateFieldMarshaler(g, fd.MapValue(), "v", false)
		g.P("mp = false")
		g.P("}")
		g.P("w.WriteObjectEnd()")
	case fd.Message() != nil:
		if wktSet[fd.Message().FullName()] {
			g.P("data, err := ", protojsonPkg.Ident("Marshal"), "(", name, ")")
			g.P("if err != nil {")
			g.P("w.Error = err")
			g.P("return")
			g.P("}")
			g.P("w.WriteVal(", jsonPkg.Ident("RawMessage"), "(data))")
		} else {
			g.P("if m, ok := any(", name, ").(interface{ WriteJSON(*", jsoniterPkg.Ident("Stream"), ") }); ok {")
			g.P("m.WriteJSON(w)")
			g.P("} else {")
			g.P("data, err := ", protojsonPkg.Ident("Marshal"), "(", name, ")")
			g.P("if err != nil {")
			g.P("w.Error = err")
			g.P("return")
			g.P("}")
			g.P("w.WriteVal(", jsonPkg.Ident("RawMessage"), "(data))")
			g.P("}")
		}
	case fd.Enum() != nil:
		g.P("w.WriteString((", name, ").String())")
	case fd.Kind() == protoreflect.BytesKind:
		g.P("w.WriteString(", base64Pkg.Ident("StdEncoding.EncodeToString"), "(", name, "))")
	default:
		g.P("w.Write", strings.Title(lkpScalarFieldTyp(fd.Kind())), "(", name, ")")
		// Only scalar fields
	}
}

func genConj(g *protogen.GeneratedFile) {
	g.P("var (")
	g.P("Or = ", nidhiPkg.Ident("Or"))
	g.P("And = ", nidhiPkg.Ident("And"))
	g.P("Not = ", nidhiPkg.Ident("Not"))
	g.P(")")
}

func genSchema(g *protogen.GeneratedFile, message *protogen.Message) {
	g.P("var schema = new", message.GoIdent.GoName, "Field(nil)")
	g.P("var (")
	for _, field := range message.Fields {
		g.P(field.GoName, " = schema.", field.GoName)
	}
	g.P(")")
}

func genSchemaTypes(g *protogen.GeneratedFile, m *protogen.Message, p *protogen.Plugin) {
	msgs := getUniqueMessages(m)
	for _, msg := range msgs {
		genFieldType(g, msg, p)
		g.P("")
	}
}

func genFieldType(g *protogen.GeneratedFile, m *protogen.Message, p *protogen.Plugin) {
	g.P("type ", lcc(m.GoIdent.GoName), "Field struct {")
	g.P(nidhiPkg.Ident("DocField"), "[*", m.GoIdent, "]")
	for _, f := range m.Fields {
		g.P(append([]any{f.GoName, " "}, getFieldTyp(f, p)...)...)
	}
	g.P("}")
	g.P("")
	g.P("func new", m.GoIdent.GoName, "Field(path []string) ", lcc(m.GoIdent.GoName), "Field", " {")
	g.P("return ", lcc(m.GoIdent.GoName), "Field{")
	g.P(nidhiPkg.Ident("NewDocField"), "[*", m.GoIdent, "](path),")
	for _, f := range m.Fields {
		g.P(append(getFieldTypCtr(f, p), ",")...)
	}
	g.P("}")
	g.P("}")
}

func getFieldTyp(f *protogen.Field, p *protogen.Plugin) []any {
	if f.Desc.IsMap() {
		return append(
			[]any{nidhiPkg.Ident("DocField"), "[", "map[", lkpScalarFieldTyp(f.Desc.MapKey().Kind()), "]"},
			append(lkpMapValueImport(f.Desc.MapValue(), p), "]")...,
		)
	}
	if f.Desc.IsList() {
		if f.Message != nil { // Message list
			return []any{
				nidhiPkg.Ident("ListField"),
				"[*", f.Message.GoIdent, ", []*", f.Message.GoIdent, ", ", lcc(f.Message.GoIdent.GoName), "Field]",
			}
		}
		typ := lkpScalarFieldTyp(f.Desc.Kind())
		return []any{
			nidhiPkg.Ident("ListField"),
			"[", typ, ", []", typ, ", ", nidhiPkg.Ident(getScalarFieldTyp(f.Desc.Kind())), "]",
		}
	}
	if f.Message != nil {
		return []any{lcc(f.Message.GoIdent.GoName), "Field"}
	}
	return []any{nidhiPkg.Ident(getScalarFieldTyp(f.Desc.Kind()))}
}

func getFieldTypCtr(f *protogen.Field, p *protogen.Plugin) []any {
	if f.Desc.IsMap() {
		idents := getFieldTyp(f, p)
		fd := idents[0].(protogen.GoIdent)
		fd.GoName = "New" + fd.GoName
		idents[0] = fd
		return append(
			idents,
			`(append(path, "`, f.Desc.JSONName(), `"))`,
		)

	}
	if f.Desc.IsList() {
		if f.Message != nil { // Message list
			return []any{
				nidhiPkg.Ident("NewListField"),
				"[*", f.Message.GoIdent, ", []*", f.Message.GoIdent, ", ", lcc(f.Message.GoIdent.GoName), "Field]",
				`(append(path, "`, f.Desc.JSONName(), `"), func (i int)`, lcc(f.Message.GoIdent.GoName), "Field {",
				`return new`, f.Message.GoIdent.GoName, "Field", `(append(path, "`, f.Desc.JSONName(), `", `, strconvPkh.Ident("Itoa"), `(i)))`,
				"})",
			}
		}
		typ := lkpScalarFieldTyp(f.Desc.Kind())
		return []any{
			nidhiPkg.Ident("NewListField"),
			"[", typ, ", []", typ, ",", nidhiPkg.Ident(getScalarFieldTyp(f.Desc.Kind())), "](",
			"append(path, \"", f.Desc.JSONName(), "\"), func (i int) ", nidhiPkg.Ident(getScalarFieldTyp(f.Desc.Kind())), "{",
			"return ", nidhiPkg.Ident("New" + getScalarFieldTyp(f.Desc.Kind())), "(append(path, \"", f.Desc.JSONName(), "\", ", strconvPkh.Ident("Itoa"), "(i)))",
			"})",
		}
	}
	if f.Message != nil {
		return []any{"new", f.Message.GoIdent.GoName, "Field(append(path, \"", f.Desc.JSONName(), "\"))"}
	}
	return []any{nidhiPkg.Ident("New" + getScalarFieldTyp(f.Desc.Kind())), "(append(path, \"", f.Desc.JSONName(), "\"))"}
}

func getScalarFieldTyp(kind protoreflect.Kind) string {
	switch kind {
	case protoreflect.StringKind, protoreflect.BytesKind, protoreflect.EnumKind:
		return "StringField"
	case protoreflect.BoolKind:
		return "BoolField"
	case protoreflect.DoubleKind, protoreflect.FloatKind:
		return "FloatField"
	case protoreflect.Int32Kind,
		protoreflect.Sint32Kind,
		protoreflect.Sfixed32Kind,
		protoreflect.Uint32Kind,
		protoreflect.Fixed32Kind,
		protoreflect.Int64Kind,
		protoreflect.Sint64Kind,
		protoreflect.Sfixed64Kind,
		protoreflect.Uint64Kind,
		protoreflect.Fixed64Kind:
		return "IntField"
	default:
		panic("this is a bug")
	}
}

func getUniqueMessages(m *protogen.Message) []*protogen.Message {
	msgs := map[string]*protogen.Message{
		string(m.Desc.FullName()): m,
	}
	for _, f := range m.Fields {
		if f.Message != nil && !f.Desc.IsMap() {
			for _, m := range getUniqueMessages(f.Message) {
				msgs[string(m.Desc.FullName())] = m
			}
		}
	}
	return maps.Values(msgs)
}

func genSchemaType(g *protogen.GeneratedFile, msg *protogen.Message, prefix string, inSlice uint) {
	for _, f := range msg.Fields {
		g.P(prefix, f.GoName, " struct {")
		genSelectorType(g, f, prefix, inSlice)
		if f.Message != nil {
			for _, sf := range f.Message.Fields {
				g.P(sf.GoName, " ", prefix, f.GoName, sf.GoName)
			}
		}
		g.P("}")
		if f.Message != nil {
			sliceCount := inSlice
			if f.Desc.IsList() {
				sliceCount++
			}
			genSchemaType(g, f.Message, prefix+f.GoName, sliceCount)
		}
	}
}

func genSelectorType(g *protogen.GeneratedFile, field *protogen.Field, prefix string, inSlice uint) {
	_, fieldType, _ := getFieldInfo(field, inSlice)
	g.P(nidhiPkg.Ident(fieldType))
}

func genNewStore(g *protogen.GeneratedFile, m *protogen.Message, id *protogen.Field) {
	g.P("// Store is a [nidhi.Store] for ", m.GoIdent.GoName, ".")
	g.P("type Store = ", nidhiPkg.Ident("Store"), "[", m.GoIdent, "]")
	g.P()
	g.P("// NewStore is a document store for ", m.GoIdent.GoName)
	g.P("func NewStore(")
	g.P("ctx ", contextPkg.Ident("Context"), ",")
	g.P("db *", sqlPkg.Ident("DB"), ",")
	g.P("opt ", nidhiPkg.Ident("StoreOptions"), ",")
	g.P(") (*Store, error) {")
	g.P("return ", nidhiPkg.Ident("NewStore"), "(")
	g.P("ctx,")
	g.P("db,")
	g.P(`"`, strings.ReplaceAll(string(m.Desc.ParentFile().Package()), ".", "_"), `",`)
	g.P(`"`, strings.ToLower(m.GoIdent.GoName), `",`)
	g.P("[]string{")
	for _, field := range m.Fields {
		g.P(`"`, field.Desc.JSONName(), `",`)
	}
	g.P("},")
	g.P("func(x *", m.GoIdent, ") string { return x.", id.GoName, " },")
	g.P("func(x *", m.GoIdent, ", id string) {x.", id.GoName, " = id },")
	g.P("opt,")
	g.P(")")
	g.P("}")
}

func lcc(ucc string) string {
	return strings.ToLower(ucc[:1]) + ucc[1:]
}

func getFieldInfo(field *protogen.Field, inSlice uint) (typ string, Field string, def string) {
	defer func() {
		if field.Desc.HasOptionalKeyword() {
			def = "NULL"
		}
		sliceCount := inSlice
		if field.Desc.IsList() {
			sliceCount++
		}
		if sliceCount > 0 && typ != "JSONB" {
			Field = strings.ReplaceAll(Field, "Field", "SliceField")
			typ += strings.Repeat("[]", int(sliceCount))
			def = "'{}'"
		}
	}()
	switch {
	case field.Desc.IsMap():
		return "JSONB", "JsonField", "'{}'"
	case field.Message != nil:
		if wktSet[field.Message.Desc.FullName()] {
			return lkpWktTyp(field.Message.Desc.FullName())
		} else {
			return "JSONB", "JsonField", "'{}'"
		}
	case field.Enum != nil:
		vd := field.Enum.Desc.Values().ByNumber(0)
		if vd == nil {
			log.Println("Enum doesn't have a ZERO based default value")
		}
		return "TEXT", "StringField", "'" + string(vd.Name()) + "'"
	default:
		// Only scalar fields
		return lkpScalarTyp(field.Desc.Kind())
	}
}

func lkpScalarTyp(kind protoreflect.Kind) (string, string, string) {
	switch kind {
	case protoreflect.StringKind, protoreflect.BytesKind:
		return "TEXT", "StringField", "''"
	case protoreflect.BoolKind:
		return "BOOLEAN", "BoolField", "FALSE"
	case protoreflect.DoubleKind:
		return "DOUBLE PRECISION", "FloatField", "0"
	case protoreflect.FloatKind:
		return "REAL", "FloatField", "0"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind, protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "INTEGER", "IntField", "0"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "BIGINT", "IntField", "0"
	default:
		panic("this is a bug")

	}
}

func lkpWktTyp(name protoreflect.FullName) (string, string, string) {
	switch name {
	case (&structpb.Struct{}).ProtoReflect().Descriptor().FullName(),
		(&structpb.ListValue{}).ProtoReflect().Descriptor().FullName(),
		(&structpb.Value{}).ProtoReflect().Descriptor().FullName(),
		(&anypb.Any{}).ProtoReflect().Descriptor().FullName(),
		(new(structpb.NullValue)).Descriptor().FullName():
		return "JSONB", "JsonField", "NULL"
	case (&fieldmaskpb.FieldMask{}).ProtoReflect().Descriptor().FullName():
		return "TEXT", "StringField", "''"
	case (&timestamppb.Timestamp{}).ProtoReflect().Descriptor().FullName():
		return "TIMESTAMP", "TimeField", "'1970-01-01 00:00:00'"
	case (&durationpb.Duration{}).ProtoReflect().Descriptor().FullName():
		return "SEField P 6 ", "UNKNOWN", "'0s'"
	case (&emptypb.Empty{}).ProtoReflect().Descriptor().FullName():
		return "JSONB", "JsonField", "'{}'"
	case (&wrapperspb.BoolValue{}).ProtoReflect().Descriptor().FullName():
		return "BOOLEAN", "BoolField", "FALSE"
	case (&wrapperspb.StringValue{}).ProtoReflect().Descriptor().FullName(), (&wrapperspb.BytesValue{}).ProtoReflect().Descriptor().FullName():
		return "TEXT", "StringField", "''"
	case (&wrapperspb.Int32Value{}).ProtoReflect().Descriptor().FullName():
		return "INTEGER", "IntField", "0"
	case (&wrapperspb.Int64Value{}).ProtoReflect().Descriptor().FullName():
		return "BIGINT", "IntField", "0"
	case (&wrapperspb.UInt32Value{}).ProtoReflect().Descriptor().FullName():
		return "INTEGER", "IntField", "0"
	case (&wrapperspb.UInt64Value{}).ProtoReflect().Descriptor().FullName():
		return "BIGINT", "IntField", "0"
	case (&wrapperspb.FloatValue{}).ProtoReflect().Descriptor().FullName():
		return "REAL", "FloatField", "0"
	case (&wrapperspb.DoubleValue{}).ProtoReflect().Descriptor().FullName():
		return "DOUBLE PRECISION", "FloatField", "0"
	default:
		panic("unknown wkt")
	}
}

func lkpFieldType(field *protogen.Field, plugin *protogen.Plugin) (fn []any) {
	defer func() {
		if field.Desc.HasOptionalKeyword() {
			fn = append([]any{"*"}, fn...)
		}
		if field.Desc.IsList() {
			fn[0] = "*[]"
		}
	}()
	switch {
	case field.Desc.IsMap():
		return append([]any{"*", "map[", lkpScalarFieldTyp(field.Desc.MapKey().Kind()), "]"}, lkpMapValueImport(field.Desc.MapValue(), plugin)...)
	case field.Message != nil:
		return []any{"*", "*", field.Message.GoIdent}
	case field.Enum != nil:
		return []any{"*", field.Enum.GoIdent}
	default:
		// Only scalar fields
		return []any{"*", lkpScalarFieldTyp(field.Desc.Kind())}
	}
}

func lkpScalarFieldTyp(kind protoreflect.Kind) string {
	switch kind {
	case protoreflect.StringKind, protoreflect.EnumKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	default:
		// This should never happen
		return "Unknown"
	}
}

func lkpMapValueImport(fd protoreflect.FieldDescriptor, plugin *protogen.Plugin) []any {
	file := plugin.FilesByPath[fd.ParentFile().Path()]
	switch {
	case fd.Message() != nil:
		for _, msg := range file.Messages {
			if msg.Desc.FullName() == fd.Message().FullName() {
				return []any{"*", msg.GoIdent}
			}
		}
	case fd.Enum() != nil:
		for _, enum := range file.Enums {
			if enum.Desc.FullName() == fd.Enum().FullName() {
				return []any{enum.GoIdent}
			}
		}
	default:
		return []any{lkpScalarFieldTyp(fd.Kind())}
	}
	panic("should not happen")
}
